#Calculate clustering and mudularity for pre-gated samusik set at ko45 with Phenograph

#To evaluate Phenograph on uncurated data set
import phenograph
from sklearn.neighbors import KDTree
import numpy as np
from scipy.sparse import coo_matrix
import matplotlib.pyplot as plt
import os
import sklearn
import fcsparser
import timeit
from multiprocessing import Pool
from contextlib import closing
from itertools import repeat

def calc_jaccard(i, idx):
    """Compute the Jaccard coefficient between i and i's direct neighbors"""
    coefficients = np.fromiter((len(set(idx[i]).intersection(set(idx[j]))) for j in idx[i]), dtype=float)
    coefficients /= (2 * idx.shape[1] - coefficients)
    return idx[i], coefficients

def parallel_jaccard_kernel(idx):
    """Compute Jaccard coefficient between nearest-neighbor sets in parallel
    :param idx: n-by-k integer matrix of k-nearest neighbors
    :return (i, j, s): row indices, column indices, and nonzero values for a sparse adjacency matrix
    """
    n = len(idx)
    with closing(Pool()) as pool:
        jaccard_values = pool.starmap(calc_jaccard, zip(range(n), repeat(idx)))
    return jaccard_values



#Set the variables
ROOT = '/mnt/f/Brinkman group/current/Stepan/RobinsonFlowComparisonALL'
DATA_DIR = "/benchmark_data_sets/"
DATA = 'Samusik_all.fcs'

MANUAL_PHENOGRAPH = "/results/manual/phenoGraph/"
RES_DIR_PHENOGRAPH = "/results/auto/PhenoGraph/"
CALC_NAME = "Samusik_gated45"
SET_NAME = 'Samusik_all'

meta, data = fcsparser.parse(ROOT + DATA_DIR + DATA, meta_data_only=False, reformat_meta=True, output_format='ndarray')
meta['_channels_']
#extract markers
l=data[:, 53]
data = data[~np.isnan(l), :]
data = data[:, 8:47]

res=[]
for i in [45]:
    communities, graph, Q = phenograph.cluster(data, k=i, n_jobs=5)
    res.append([communities, graph, Q])

np.save('graph.save', graph)

#plt.hist(communities)

#save true labels
#if not os.path.exists(ROOT + MANUAL_PHENOGRAPH + CALC_NAME):
#    os.makedirs(ROOT + MANUAL_PHENOGRAPH + CALC_NAME)
#np.savetxt(ROOT + MANUAL_PHENOGRAPH + CALC_NAME+"/"+"Python_true_labels_phenoGraph_" + SET_NAME + ".txt", newline='\n',
#           fmt='%i', header='label', X = (l).astype(int))

# save cluster labels
if not os.path.exists(ROOT + RES_DIR_PHENOGRAPH + CALC_NAME):
    os.makedirs(ROOT + RES_DIR_PHENOGRAPH + CALC_NAME)
for k in range(1):
    com=res[k][0]
    np.savetxt(ROOT + RES_DIR_PHENOGRAPH + CALC_NAME+"/"+'k=' + str(k*15+15)
               + "Python_assigned_labels_phenoGraph_" + SET_NAME + ".txt", com, fmt='%d',  header='label', newline='\n' )

#save data
if not os.path.exists(ROOT +  MANUAL_PHENOGRAPH + CALC_NAME):
    os.makedirs(ROOT +  MANUAL_PHENOGRAPH + CALC_NAME)
np.savetxt(ROOT + MANUAL_PHENOGRAPH + CALC_NAME+"/"+"data_" + SET_NAME + ".txt", newline='\n',
           fmt='%f', X = (data[:, ]))

a=np.zeros((514386,3), dtype='int,int,float')

import networkx
G = networkx.from_scipy_sparse_matrix(graph)
import community
mod = community.modularity(communities, G)

gM = coo_matrix.tocsr(graph)
